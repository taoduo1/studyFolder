Spring IoC循环依赖解决（三级缓存机制）
spring 通过三级缓存解决循环依赖的问题
第一级存储存储完全初始化的单例 Bean（最终产物）。
第二级存储存储实例化后但未初始化的早期引用（半成品对象），用于解决循环依赖时的临时暴露。
第三级存储生成早期引用的工厂（ObjectFactory），避免每次都重新创建工厂实例。
spring 解决循环依赖的流程是
1. 实例化Bean A
    1.1 触发创建：调用getBean("A")时，发现一级缓存（singletonObjects）无A，进入创建流程。
    1.2 实例化对象：通过构造方法创建A的实例（此时A的属性未填充）。
    1.3 暴露早期引用：将A的ObjectFactory（工厂接口）存入三级缓存（singletonFactories），用于后续生成早期引用。
2. Bean A尝试注入依赖（如Bean B）
    2.1触发依赖注入：在填充A的属性时，发现依赖B，调用getBean("B")。
    2.2发现Bean B未创建：容器检查一级缓存无B，进入Bean B的创建流程。
3. 实例化Bean B
    3.1 实例化对象：通过构造方法创建B的实例（此时B的属性未填充）。
    3.2 暴露早期引用：将B的ObjectFactory存入三级缓存。
    3.3 Bean B尝试注入依赖（Bean A）：在填充B的属性时，发现依赖A，调用getBean("A")。
4. 解决循环依赖的关键步骤
    4.1 从三级缓存获取早期引用：容器检查三级缓存，发现A的ObjectFactory存在，通过getObject()生成A的早期引用（半成品对象），并存入二级缓存（earlySingletonObjects）。
    4.2 注入早期引用：B完成属性填充后，将A的早期引用注入B的属性中。
5. 完成Bean初始化
    5.1 Bean B初始化完成：B调用初始化方法（如@PostConstruct），存入一级缓存并从二级缓存移除。
    5.2 Bean A继续初始化：回到Bean A的创建流程，从二级缓存获取B的早期引用（或代理对象），完成属性填充。
    5.3 Bean A初始化完成：调用初始化方法，存入一级缓存并从二级缓存移除。
6. 代理对象处理（可选）
    AOP代理场景：若A需要代理，三级缓存通过ObjectFactory生成代理对象，确保注入的A是最终代理实例。
7. 循环依赖的限制
    仅支持单例Bean：原型（Prototype）Bean每次请求均创建新实例，无法通过缓存解决循环依赖。
    构造器注入无法解决：构造器注入要求实例化时完成依赖注入，无法提前暴露引用。
流程总结
    实例化Bean A→ 将A的ObjectFactory存入三级缓存。
    Bean A依赖Bean B → 创建Bean B并暴露其ObjectFactory。
    Bean B依赖Bean A → 从三级缓存获取A的早期引用，注入到B。
    完成Bean B初始化 → 将B存入一级缓存。
    Bean A获取Bean B的早期引用 → 完成属性填充和初始化。
    通过三级缓存机制，Spring在Bean生命周期中提前暴露未完全初始化的引用，打破循环依赖链。
为什么不用两级缓存？
   若仅有一级缓存和二级缓存，则无法处理以下场景：
      循环依赖中的代理对象：若Bean A需要代理，但代理生成在初始化完成后，那么在循环依赖阶段，Bean B无法获取到代理后的A实例。
      早期引用的唯一性：三级缓存通过工厂方法控制早期引用的生成，避免多个线程同时创建相同Bean的早期实例。

Spring AOP动态代理（JDK vs CGLIB性能差异）
JDK 和 CGLIB 的性能差异主要体现在两个维度：
代理生成效率：JDK 通过反射快速生成接口代理类，适合高频创建场景；CGLIB 因需生成子类字节码，生成时间较长。
方法执行效率：CGLIB 直接调用子类方法，性能远高于 JDK 的反射调用（约 10 倍）。
选择策略：
    若目标类实现了接口，优先使用 JDK 动态代理（如 Spring 默认行为）。
    若需代理无接口的类或追求更高执行性能，选择 CGLIB
    注意：Spring 默认根据目标类是否实现接口自动切换代理方式，也可通过配置强制使用 CGLIB
JDK 动态代理
    机制：基于接口代理，通过反射动态生成实现目标接口的代理类。
核心类：Proxy 和 InvocationHandler，代理对象调用方法时触发 invoke() 方法，通过反射执行目标逻辑。
    限制：只能代理实现了接口的类。
CGLIB 动态代理
    机制：基于继承代理，通过字节码操作（ASM）生成目标类的子类，重写父类方法并插入增强逻辑。
核心类：Enhancer 和 MethodInterceptor，代理对象直接调用子类重写的方法，无需反射。
    限制：无法代理 final 类或方法（因无法继承/重写）。
差异总结：
JDK 代理是接口驱动，CGLIB 是类驱动。
JDK 依赖反射，CGLIB 依赖字节码生成

Spring事务传播机制（嵌套事务回滚场景）

REQUIRED
如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。
方法1 方法2 都加了@Transactional注解
方法1 调用方法2 方法2 insert后报错，方法1 和方法2 的内容都会回滚
SUPPORTS
如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。
方法1 不加@Transactional注解 方法2 @Transactional 注解propagation = Propagation.SUPPORTS
方法1 调用方法2 方法2 insert后报错，方法1 的内容不会回滚

方法1 加@Transactional注解 方法2 @Transactional 注解propagation = Propagation.SUPPORTS
方法1 调用方法2 方法2 insert后报错，方法1 的内容会回滚

MANDATORY
如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常
方法1 不加@Transactional注解 方法2 @Transactional 注解propagation = Propagation.MANDATORY
运行时程序会报错

REQUIRES_NEW
创建一个新的事务,如果当前存在事务,则把当前事务挂起
方法1 加@Transactional注解 方法2 @Transactional 注解propagation = Propagation.REQUIRES_NEW
方法1 调用方法2 方法1 insert后报错，方法1 的内容会回滚 方法2的内容不会回滚

NOT_SUPPORTED
以非事务方式运行，如果当前存在事务，则把当前事务挂起。
方法1 不加@Transactional注解 方法2 @Transactional 注解propagation = Propagation.NOT_SUPPORTED
方法1 调用方法2 方法1 insert后报错，方法1 方法2 的内容都不会回滚

方法1 加@Transactional注解 方法2 @Transactional 注解propagation = Propagation.NOT_SUPPORTED
方法1 调用方法2 方法1 insert后报错，方法1 的内容会回滚 方法2的内容不会回滚

NEVER
以非事务方式运行，如果当前存在事务，则抛出异常。
方法1 不加@Transactional注解 方法2 @Transactional 注解propagation = Propagation.NEVER
方法1 调用方法2 方法1 insert后报错，方法1 方法2 的内容都不会回滚

方法1 加@Transactional注解 方法2 @Transactional 注解propagation = Propagation.NEVER
方法1 调用方法2 方法1 insert后报错，方法1 方法2 的内容都不会入库

NESTED
如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于REQUIRED

方法1 不加@Transactional注解 方法2 @Transactional 注解propagation = Propagation.NESTED
方法1 调用方法2 方法1 insert后报错，方法1 方法2 的内容都不会回滚

方法1 加@Transactional注解 方法2 @Transactional 注解propagation = Propagation.NESTED
方法1 调用方法2 方法1 insert后报错，方法1 方法2 的内容都会回滚

Spring Boot自动配置原理（@Conditional条件装配）

