线上系统问题的排查是一个常见且关键的任务。以下是一个系统化的排查思路和步骤:
1.问题确认和信息收集
问题描述:明确问题的具体表现，如系统响应慢、服务不可用、数据异常等影响范围:确定问题影响的用户群体、功能模块或服务。
时间点:确定问题发生的时间，是持续性还是间歇性。。
· 环境信息:收集系统环境信息，如服务器配置、JDK版本、应用版本等。
2.快速响应
评估严重程度:根据影响范围和业务重要性评估问题严重程度。
应急措施:如果问题严重，考虑采取紧急措施，如服务降级、流量限制或回滚版本。
3.日志分析
应用日志:检查应用日志中的错误信息、异常堆栈等。
系统日志:查看操作系统日志，如Linux的/var/1og/messages
中间件日志:检查数据库、缓存、消息队列等中间件的日志。
4.监控数据分析
系统监控:查看CPU、内存、磁盘I/0、网络等系统资源使用情况。JVM监控:分析GC日志、堆内存使用、线程状态等
应用性能监控:检查请求响应时间、吞吐量、错误率等指标。
5.网络分析
网络连接:检查网络连接状态，如防火墙设置、端口开放情况。
网络性能:分析网络延迟、丢包率等指标。
6.数据库分析
慢查询日志:检查是否存在性能低下的SQL语句。
数据库状态:查看数据库连接数、锁等待情况等，
执行计划:分析关键SQL的执行计划是否合理。
7.代码级别分析
线程转储:获取Java线程转储(Thread Dump)分析线程状态
堆转储:必要时获取堆转储(Heap Dump)分析内存问题
代码回顾:检查最近的代码变更，是否引入了新的bug。
8.性能分析与监控工具使用
Profiler:使用Arthas、JProfiler等工具进行CPU和内存分析
监控工具:使用prometheus、grafana、skywalking等工具进行全链路跟踪。
9.复现问题
·在测试环境中尝试复现问题，以便更深入地分析。
·模拟生产环境的负载和数据量。
10.根因分析
·基于收集到的所有信息，进行根因分析。
11.解决方案
制定短期解决方案以快速修复问题。
规划长期优化方案以防止类似问题再次发生
12.验证和监控
在测试环境验证解决方案的有效性。
谨慎地将解决方案应用到生产环境。
持续监控系统，确保问题得到彻底解决。
13.复盘和总结
编写详细的问题分析报告
总结经验教训，更新相关文档和最佳实践。
实际案例
假设遇到一个Java应用响应变慢的问题:
1.问题确认:确认响应时间从原来的200ms增加到2000ms。
2.日志分析:应用日志显示大量GC警告。
3.监控数据:JVM监控显示老年代内存使用率高，FullGC频繁。
4.线程分析:Thread Dump显示多个线程在等待数据库连接。
5.数据库分析:发现数据库连接池耗尽，大量慢查询。
6.代码审查:最近的代码变更引入了一个无效的数据库连接释放。
7.根因:由于连接未正确释放，导致连接池耗尽，引发了大量等待，进而导致内存积压和频繁GC8.解决方案:修复连接释放的bug，优化相关SQL，增加连接池大小。
9.验证和监控:修复后，响应时间恢复正常，GC频率降低:
通过这种系统化的方法，我们能够有效地定位和解决线上问题，同时积累经验以预防未来可能出现的类似问题。



mysql语句优化
sql 开启慢查询
slow_query_log = 1：启用慢查询日志。
slow_query_log_file：指定慢查询日志文件的路径。
long_query_time：设置被认为是“慢”的查询的执行时间阈值，单位为秒。默认值通常是10秒。
log_queries_not_using_indexes：如果设置为1，则记录所有没有使用索引的查询。
做MySQL优化，我们要善用EXPLAIN查看SQL执行计划。
下面来个简单的示例，标注（1、2、3、4、5）我们要重点关注的数据：

type列 连接类型。一个好的SQL语句至少要达到range级别。杜绝出现all级别。
key列 使用到的索引名。如果没有选择索引，值是NULL。可以采取强制索引方式。
key_len列 索引长度。
rows列 扫描行数。该值是个预估值。
extra列 详细说明。注意，常见的不太友好的值，如下：Using filesort，Using temporary。
SQL语句中IN包含的值不应过多
MySQL对于IN做了相应的优化，即将IN中的常量全部存储在一个数组里面，而且这个数组是排好序的。但是如果数值较多，产生的消耗也是比较大的。再例如：select id from t where num in(1,2,3) 对于连续的数值，能用between就不要用in了；再或者使用连接来替换。
如果排序字段没有用到索引，就尽量少排序
如果限制条件中其他字段没有索引，尽量少用or
or两边的字段中，如果有一个不是索引字段，而其他条件也不是索引字段，会造成该查询不走索引的情况。很多时候使用union all或者是union（必要的时候）的方式来代替“or”会得到更好的效果。
尽量用union all代替union
区分in和exists、not in和not exists
select * from 表A where id in (select id from 表B) 相当于
select * from 表A where exists(select * from 表B where 表B.id=表A.id)
区分in和exists主要是造成了驱动顺序的改变（这是性能变化的关键），如果是exists，那么以外层表为驱动表，先被访问，如果是IN，那么先执行子查询。所以IN适合于外表大而内表小的情况；EXISTS适合于外表小而内表大的情况。
关于not in和not exists，推荐使用not exists，不仅仅是效率问题，not in可能存在逻辑问题。如何高效的写出一个替代not exists的SQL语句？
原语句：
select colname … from A表 where a.id not in (select b.id from B表)
优化后：
select colname … from A表 Left join B表 on where a.id = b.id where b.id is null
必要时可以使用force index来强制查询走某个索引
有的时候MySQL优化器采取它认为合适的索引来检索SQL语句，但是可能它所采用的索引并不是我们想要的。这时就可以采用forceindex来强制优化器使用我们制定的索引。
FORCE INDEX
USE INDEX (index_name1, index_name2)
在where 上面加
避免在where子句中对字段进行表达式操作
避免隐式类型转换
对于联合索引来说，要遵守最左前缀法则
举列来说索引含有字段id、name、school，可以直接用id字段，也可以id、name这样的顺序，但是name;school都无法使用这个索引。所以在创建联合索引的时候一定要注意索引字段顺序，常用的查询字段放在最前面。
范围查询需要注意：
对于联合索引来说，如果存在范围查询，比如between、>、<等条件时，会造成后面的索引字段失效。
索引跳跃扫描（mysql 8.0.13及以上版本）
主要针对多个字段的复合索引：当复合索引对应字段会排序，所以在第二字段上命中完则会跳过到下一个第一字段中，这样就能省下很多时间，
并且第一字段要散列度不是很好的情况 （第一字段只会有少数几个值）