<h1>0 前言</h1>
本书讲述了InnoDB存储引擎的诸多功能和特性，还阐述了如何正确的使用这些功能和特性。

<h1>1 MySQL体系结构和存储引擎</h1>

<h2>1.1 定义数据库和实例</h2>
数据库和实例的定义

数据库：物理操作系统文件或其他形式文件类型的集合，在MySQL数据库中，数据库文件可以是frm、MYD、MYI结尾的文件

实例：MySQL数据库由后台线程以及一个共享的内存区组成，共享的内存可以被运行的后台线程所共享，数据库实例才是真正用于操作数据库文件的。
数据库操作insert、update 等是通过实例操作的

在MySQL中实例与数据库的关系通常是一一对应的，但是也存在集群环境下可能存在一个数据库被多个实例使用的情况。

MySQL被设计成一个单进程多线程架构的数据库，在系统上的表现就是一个进程。

<h2>1.2 MySQL体系结构</h2>

![](InnoDB存储引擎附录/MySQL体系结构.png)

如图所示：MySQL由以下几部分组成

1. 连接池组件
2. 管理服务和工具组件
3. SQL接口组件
4. 查询分析组件
5. 优化器组件
6. 缓冲组件
7. 插件式存储引擎
8. 物理文件

从图中可以看到，MySQL数据库区别于其他的数据库的最重要一个特点就是其插件式的表存储引擎。
MySQL插件式的存储引擎架构提供了一系列标准的管理和服务支持，这些标准与存储引擎本身无关，可能是每个系统必须的。
如SQL分析和优化器等，而存储引擎是底层物理结构的实现，每个存储引擎开发者可以按自己的意愿来进行开发。

需要特别注意的是，存储引擎是基于表的，而不是数据库。


<h2>1.3 MySQL存储引擎 </h2>
MySQL存储引擎是区别于其他数据库的一个重要特性。
存储引擎的好处是，每个存储引擎都有各自的特点，能够根据具体的应用建立不同的存储引擎表。

<h3>1.3.1 InnoDB存储引擎 </h3>
InnoDB存储引擎支持事务，其设计目标主要是面向在线事务处理（OLTP）的应用。
其特点是支持行级锁、支持外键、支持类似oracle的非读定锁（默认读取不会产生锁），MySQL从5.5.8开始后，默认存储引擎为InnoDB。

InnoDB存储引擎将数据放在一个逻辑的表空间中，从MySQL4.1之后它将每个表单独存放在一个ibd文件中。

InnoDB通过多版本并发控制（MVCC）来获得高并发性，并且实现了SQL标准的4个隔离级别，默认为REPEATABLE级别。
同时使用了next-key locking的策略来避免幻读，除此之外，InnoDB还提供了插入缓存、二次写、自适应哈希锁、预读等高性能和高可用的功能。

对于表中数据的存储，InnoDB存储引擎采用了聚集的方式、因此每张表的存储都是按照主键的顺序进行存储的。如果没有主键，InnoDB会为每一行生成一个6字节的ROWID，并以此作为主键。

<h3>1.3.2 MyISAM存储引擎 </h3>
MYISAM 不支持事务、表锁设计、支持全文索引，主要面向一些OLAP数据库应用。
在MySQL5.5.8之前是MySQL的默认存储引擎

MyISAM存储引擎由MYD和MYI组成，MYD用来存放数据文件，MYI用来存放索引文件。


<h3>1.3.3 NDB存储引擎 </h3>

NDB是一个集群存储引擎，类似于oracle的RAC集群。
不过与Oracle的RAC share everything架构不同的是，它的架构是 share nothing的集群架构，因此能提供更高的可用性。
NDB的特点是数据全部都放在内存中（MySQL5.1之后可以将非索引数据放在磁盘上）因此主键查找很快，并且可以通过添加节点线性的提高数据库性能，是高可用，高性能的集群系统。

NDB存储引擎的数据库连接是在MySQL层面完成的，而不是在存储引擎层面完成的，导致复杂查询的连接操作需要巨大的网络开销，所以查询很慢。

<h3>1.3.4 Memory存储引擎 </h3>
Memory存储引擎将表中的数据都放在内存中，如果数据库崩溃或重启，表中的数据都会消失，适合存临时数据的临时表。

Memory存储引擎默认使用哈希索引，而不是B+树索引。

虽然Memory很快，但是还是有一些缺陷，比如：只支持表锁、并发性能差、并且不支持TEXT和BLOB类型，而且存储varchar时，会按char去存储，因此会浪费内存

<h3>1.3.4 Archive存储引擎 </h3>
Archive存储引擎只支持insert和select操作，从MySQL5.1开始支持索引。

Archive存储引擎使用zlib算法将数据行进行压缩后存储，压缩比可达1:10，因此 Archive适合存储归档数据，如日志信息。
Archive存储引擎使用行锁来实现高并发的插入操作，但是其本身不是事务安全的存储引擎，设计目标主要是高速插入和压缩功能。

<h1>2 InnoDB存储引擎 </h1>
InnoDB是事务安全的存储引擎，设计上采用了类似oracle的架构，InnoDB存储引擎是OLTP应用中核心表的首选存储引擎。

<h2>2.1 InnoDB存储引擎的版本 </h2>

| 版本     | 内容                  |
|--------|---------------------|
| 老版本：   | 支持ACID、行锁、MVCC      |
| 1.0.x: | 增加 compress和dynamic |
| 1.1.x: | 增加 linux AIO、多回滚段   |
| 1.2.x: | 增加 全文索引支持、在线索引添加    |


<h2>2.1 InnoDB体系结构 </h2>
![](InnoDB存储引擎附录/InnoDB存储引擎体系架构.png)
图中所示,Innodb存储引擎有多个内存块，可以认为这些内存块组成了一个大的内存池，负责如下工作：

1. 维护所有进程/线程需要访问的多个内部数据结构
2. 缓存磁盘上的数据，方便快速的读取，同时在对磁盘文件数据修改之前在这里缓存
3. 重做日志（redo log）缓冲

后台线程主要作用是负责刷新内存池中的数据，同时保证在数据库发生异常的情况下InnoDB能恢复到正常运行状态

<h3>2.3.1 后台线程 </h3>
InnoDB存储引擎是多线程的模型，因此其后台有多个不同的后台线程，负责处理不同的任务

1. Master Thread

    Master Thread 是一个非常核心的后台线程，主要负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性，包括脏页的刷新，合并插入缓冲（Insert Buffer）、UNDO页的回收等
2. IO Thread

    在InnoDB存储引擎中大量使用了AIO来处理写IO请求，这样可以极大提高数据库的性能。而IO Thread的工作主要是负责这些IO请求的回调处理。
    
3. Purge Thread
   
   事务被提交后，其所使用的的undolog可能不在需要，因此需要PurgeThread来回收已经使用并分配的undo页，在InnoDB 1.1版本之前，purge操作仅在InnoDB 存储引擎的Master Thread中完成。
   而从InnoDB 1.1版本开始，purge操作可以独立到单独的线程中进行，以此来减轻Master Thread的工作，从而提高CPU使用率及提升存储引擎的性能。


<h3>2.3.2 内存 </h3>
1. 缓冲池
   
   InnoDB是基于磁盘存储的，并将其中的记录按照页的方式进行管理，因此可以将其视为基于磁盘的数据库系统，在数据库系统中，由于CPU速度与磁盘速度之间的鸿沟，基于磁盘的数据库系统通常使用缓冲池技术来提高数据库的整体性能

   缓冲池就是一块内存区域，通过内存的速度来弥补磁盘速度较慢对数据库性能的影响。在数据库中进行读取页的操作，首先将从磁盘读到的也存放在缓冲池中，这个过程称为将也“FIX”在缓冲池中，下次再读取相同的页时，首先判断该页是否在缓冲池中，若在缓冲池中，称该页被缓冲池中被命中，直接读取该页，否则，读取磁盘上的页。

   对于数据库中也的修改操作，则首先修改缓冲池中的页，然后再以一定的频率刷新到磁盘上，这里需要注意的是 **页从缓冲池刷新回磁盘的操作并不是在每次页发生更新时触发，而是通过一种称为Checkpoint的机制刷新会磁盘**

   综上所述，缓冲池的大小直接影响着数据库的整体性能。

   具体来看，缓冲池中缓存的数据页类型有：索引页，数据页、undo页、插入缓冲、自适应哈希索引、InnoDB存储的锁信息、数据字典信息。不能简单的认为，缓冲池只是缓存索引页和数据页和数据页。

   ![](InnoDB存储引擎附录/InnoDB 内存数据对象.png)
   从InnoDB 1.0.x开始，允许有多个缓冲池实例，每个页根据哈希值平均分配到不同缓冲池实例中，这样做的好处是减少数据库内部的资源竞争，增加数据库的并发处理能力。
2. LRU List、Free List 和Flush List

   通常来说 数据库中的缓冲池是通过LRU（最近最少使用）算法来进行管理的。即最频繁使用的页在LRU列表的前端，最少使用的页在LRU列表的尾端，当缓冲池不能存放新读取的页时，将首先释放LRU列表中尾端的页。

   lru链表：用来存储内存中的缓存数据。
   free链表：用来存放所有的空闲页，每次需要数据页存储数据时，就首先检测free中有没有空闲的页来分配。
   flush链表：在内存中被修改但还没有刷新到磁盘的数据页列表，就是所谓的脏页列表，内存中的数据跟对应的磁盘上的数据不一致，属于该列表的页面同样存在于lru列表中，但反之未必。

3. 重做日志缓存

   InnoDB的内存区域除了有缓冲池外，还有重做日志缓冲，InnoDB首先将重做日志信息先放入这个缓冲区，然后按一定频率刷新到重做日志文件。重做日志缓存一般不需要设置的很大，一般情况下每一秒都会将重做日志缓存刷新到日志文件，因此用户只需要保证每秒产生的事务量在这个缓冲大小之内即可。

<h3>2.4 Checkpoint技术 </h3>   
页的操作都是在缓冲池中完成的，数据库会定期将新版本的页从缓冲池刷新到磁盘。
   
但是如果每次变化后都立刻刷新进磁盘，数据库的性能就会变差，但是如果时间太长，数据库在此期间内宕机，就会导致部分数据丢失。

为了避免数据丢失的问题，当前事务都采取了 write Ahead log策略，即当事务提交时，先写重做日志，再修改页，当发生宕机导致数据丢失时，通过重做日志来完成数据的恢复。

Checkpoint技术是为了解决以下的问题：
   1. 缩短数据库的回复时间
   2. 缓冲池不够用时，将脏页刷新到磁盘
   3. 重做日志不可用时，刷新脏页

当数据库发生宕机时，数据库不需要重做所有的日志，因为 Checkpoint之前的页都已经刷回磁盘，故数据库只需要对Checkpoint 之后的重做日志进行恢复，打打缩短了恢复的时间。

此外，当缓冲池不够用时，根据LRU算法会溢出最近最少使用的页，这个页就是脏页，那么需要强制执行 Checkpoint ，将脏页刷回磁盘。

重做日志出现不可用的情况是因为当前事务数据库系统对重做日志的设计都是循环使用的，并不是让其无限增大的，这从成本管理上都是比较困难的，重做日志可以被重用的部分是指这些重做日志已经不再需要，即当数据库发生宕机时，数据库恢复操作不需要这部分的重做日志，因此这部分就可以被覆盖重用。此时重做日志还需要使用，那么必须强制产生 Checkpoint ，将缓冲池中的也至少刷新到当前重做日志的位置。

对于InnoDB而言，通过LSN（Long sequence Number）来标记版本的。 LSN是8字节的数字，单位是字节。

在InnoDB中，每次刷新多少页到磁盘、每次从哪里取脏页以及什么时间出发Checkpoint，在存储引擎内部一共有两种，分别为：
1. Sharp Checkpoint
2. Fuzzy Checkpoint

Sharp Checkpoint发生在数据库关闭时所有的脏页都刷新回磁盘，这是默认的工作方式。

Fuzzy Checkpoint 只刷新一部分脏页，而不是刷新所有的脏页回磁盘。在以下几种情况可能出现Fuzzy Checkpoint
1. Master Thread Checkpoint

差不多以每秒或每十秒的速度从缓冲池的脏页列表中刷新一定比例的页回磁盘。这个过程是异步的，此时的InnoDB可以进行其他操作，用户查询线程不会阻塞。
2. FLUSH_LRU_LIST Checkpoint

InnoDB需要保证LRU列表中需要有差不多100个空闲页可供使用，如果空闲页不足100时，InnoDB会将LRU尾部的页移除，如果这些页中有脏页的话，就会进行 Checkpoint
3. Async/Sync Flush Checkpoint

重做日志文件不可用时，需要强制将一些也刷新回磁盘，此时脏页是从脏页列表中选取的。在MySQL 5.6之前，会阻塞用户线程，5.6之后不会阻塞用户线程
4. Dirty Page too much Checkpoint
最后一种是脏页太多，导致InnoDB 强制进行 Checkpoint，是为了保证缓冲池中有足够可用的页。


<h2>2.5 Master Thread </h2>
InnoDB的主要工作都是在一个单独的后台线程 Master Thread中完成的。

<h3>2.5.1 InnoDB 1.0.x之前的 Master Thread </h3>
Master Thread 具有最高的线程优先级别。其内部由多个loop组成：主循环、后台循环、刷新循环、暂停循环。Master Thread 会根据数据库运行的状态在这几种状态中循环。

主循环通过 Thread.sleep()实现，每一秒操作包括：
1. 日志缓存刷新到磁盘，即使这个事务还没有提交（总是）
2. 合并插入缓存（可能）
3. 之多刷新100个InnoDB的缓冲池中的脏页到磁盘（可能）
4. 如果当前没有用户活动，则切换到background loop（可能）

每10秒的操作包括：
1. 刷新100个脏页到磁盘（可能的情况下）
2. 合并最多5个插入缓冲（总是）
3. 将日志缓冲刷新到磁盘（总是）
4. 删除无用的Undo页（总是）
5. 刷新100个或者10个脏页到磁盘（总是）

即使某个事务还没有提交，InnoDB任然每秒会将重做日志缓冲中的内容刷新到重做日志文件，这种方式可以使再大的事务提交的时间也是很短的。

合并插入缓存并不是每秒都会发生的，InnoDB会判断当前一秒内的IO是否小于5次，如果小于5次，InnoDB认为当前的IO压力很小，可以执行合并插入缓冲的操作。

若当前没有用户活动，或者数据库空闲时，就会切换到后台循环。后台循环会执行以下操作：
1. 删除无用的undo页（总是）
2. 合并20个插入缓冲（总是）
3. 调回到主循环（总是）
4. 不断刷新100个页直到符合条件（可能，跳转到 刷新循环）

<h2>2.6 InnoDB 关键特性 </h2>


















