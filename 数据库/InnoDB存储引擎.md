<h1>0 前言</h1>
本书讲述了InnoDB存储引擎的诸多功能和特性，还阐述了如何正确的使用这些功能和特性。

<h1>1 MySQL体系结构和存储引擎</h1>

<h2>1.1 定义数据库和实例</h2>
数据库和实例的定义

数据库：物理操作系统文件或其他形式文件类型的集合，在MySQL数据库中，数据库文件可以是frm、MYD、MYI结尾的文件

实例：MySQL数据库由后台线程以及一个共享的内存区组成，共享的内存可以被运行的后台线程所共享，数据库实例才是真正用于操作数据库文件的。
数据库操作insert、update 等是通过实例操作的

在MySQL中实例与数据库的关系通常是一一对应的，但是也存在集群环境下可能存在一个数据库被多个实例使用的情况。

MySQL被设计成一个单进程多线程架构的数据库，在系统上的表现就是一个进程。

<h2>1.2 MySQL体系结构</h2>

![](InnoDB存储引擎附录/MySQL体系结构.png)

如图所示：MySQL由以下几部分组成

1. 连接池组件
2. 管理服务和工具组件
3. SQL接口组件
4. 查询分析组件
5. 优化器组件
6. 缓冲组件
7. 插件式存储引擎
8. 物理文件

从图中可以看到，MySQL数据库区别于其他的数据库的最重要一个特点就是其插件式的表存储引擎。
MySQL插件式的存储引擎架构提供了一系列标准的管理和服务支持，这些标准与存储引擎本身无关，可能是每个系统必须的。
如SQL分析和优化器等，而存储引擎是底层物理结构的实现，每个存储引擎开发者可以按自己的意愿来进行开发。

需要特别注意的是，存储引擎是基于表的，而不是数据库。


<h2>1.3 MySQL存储引擎 </h2>
MySQL存储引擎是区别于其他数据库的一个重要特性。
存储引擎的好处是，每个存储引擎都有各自的特点，能够根据具体的应用建立不同的存储引擎表。

<h3>1.3.1 InnoDB存储引擎 </h3>
InnoDB存储引擎支持事务，其设计目标主要是面向在线事务处理（OLTP）的应用。
其特点是支持行级锁、支持外键、支持类似oracle的非读定锁（默认读取不会产生锁），MySQL从5.5.8开始后，默认存储引擎为InnoDB。

InnoDB存储引擎将数据放在一个逻辑的表空间中，从MySQL4.1之后它将每个表单独存放在一个ibd文件中。

InnoDB通过多版本并发控制（MVCC）来获得高并发性，并且实现了SQL标准的4个隔离级别，默认为REPEATABLE级别。
同时使用了next-key locking的策略来避免幻读，除此之外，InnoDB还提供了插入缓存、二次写、自适应哈希锁、预读等高性能和高可用的功能。

对于表中数据的存储，InnoDB存储引擎采用了聚集的方式、因此每张表的存储都是按照主键的顺序进行存储的。如果没有主键，InnoDB会为每一行生成一个6字节的ROWID，并以此作为主键。

<h3>1.3.2 MyISAM存储引擎 </h3>
MYISAM 不支持事务、表锁设计、支持全文索引，主要面向一些OLAP数据库应用。
在MySQL5.5.8之前是MySQL的默认存储引擎

MyISAM存储引擎由MYD和MYI组成，MYD用来存放数据文件，MYI用来存放索引文件。


<h3>1.3.3 NDB存储引擎 </h3>

NDB是一个集群存储引擎，类似于oracle的RAC集群。
不过与Oracle的RAC share everything架构不同的是，它的架构是 share nothing的集群架构，因此能提供更高的可用性。
NDB的特点是数据全部都放在内存中（MySQL5.1之后可以将非索引数据放在磁盘上）因此主键查找很快，并且可以通过添加节点线性的提高数据库性能，是高可用，高性能的集群系统。

NDB存储引擎的数据库连接是在MySQL层面完成的，而不是在存储引擎层面完成的，导致复杂查询的连接操作需要巨大的网络开销，所以查询很慢。

<h3>1.3.4 Memory存储引擎 </h3>
Memory存储引擎将表中的数据都放在内存中，如果数据库崩溃或重启，表中的数据都会消失，适合存临时数据的临时表。

Memory存储引擎默认使用哈希索引，而不是B+树索引。

虽然Memory很快，但是还是有一些缺陷，比如：只支持表锁、并发性能差、并且不支持TEXT和BLOB类型，而且存储varchar时，会按char去存储，因此会浪费内存

<h3>1.3.4 Archive存储引擎 </h3>
Archive存储引擎只支持insert和select操作，从MySQL5.1开始支持索引。

Archive存储引擎使用zlib算法将数据行进行压缩后存储，压缩比可达1:10，因此 Archive适合存储归档数据，如日志信息。
Archive存储引擎使用行锁来实现高并发的插入操作，但是其本身不是事务安全的存储引擎，设计目标主要是高速插入和压缩功能。

<h1>2 InnoDB存储引擎 </h1>
InnoDB是事务安全的存储引擎，设计上采用了类似oracle的架构，InnoDB存储引擎是OLTP应用中核心表的首选存储引擎。

<h2>2.1 InnoDB存储引擎的版本 </h2>

| 版本     | 内容                  |
|--------|---------------------|
| 老版本：   | 支持ACID、行锁、MVCC      |
| 1.0.x: | 增加 compress和dynamic |
| 1.1.x: | 增加 linux AIO、多回滚段   |
| 1.2.x: | 增加 全文索引支持、在线索引添加    |


<h2>2.1 InnoDB体系结构 </h2>
![](InnoDB存储引擎附录/InnoDB存储引擎体系架构.png)
图中所示,Innodb存储引擎有多个内存块，可以认为这些内存块组成了一个大的内存池，负责如下工作：

1. 维护所有进程/线程需要访问的多个内部数据结构
2. 缓存磁盘上的数据，方便快速的读取，同时在对磁盘文件数据修改之前在这里缓存
3. 重做日志（redo log）缓冲

后台线程主要作用是负责刷新内存池中的数据，同时保证在数据库发生异常的情况下InnoDB能恢复到正常运行状态

<h3>2.3.1 后台线程 </h3>
InnoDB存储引擎是多线程的模型，因此其后台有多个不同的后台线程，负责处理不同的任务

1. Master Thread

    Master Thread 是一个非常核心的后台线程，主要负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性，包括脏页的刷新，合并插入缓冲（Insert Buffer）、UNDO页的回收等
2. IO Thread

    在InnoDB存储引擎中大量使用了AIO来处理写IO请求，这样可以极大提高数据库的性能。而IO Thread的工作主要是负责这些IO请求的回调处理。
    
3. Purge Thread
   
   事务被提交后，其所使用的的undolog可能不在需要，因此需要PurgeThread来回收已经使用并分配的undo页，在InnoDB 1.1版本之前，purge操作仅在InnoDB 存储引擎的Master Thread中完成。
   而从InnoDB 1.1版本开始，purge操作可以独立到单独的线程中进行，以此来减轻Master Thread的工作，从而提高CPU使用率及提升存储引擎的性能。


<h3>2.3.2 内存 </h3>
1. 缓冲池
   
   InnoDB是基于磁盘存储的，并将其中的记录按照页的方式进行管理，因此可以将其视为基于磁盘的数据库系统，在数据库系统中，由于CPU速度与磁盘速度之间的鸿沟，基于磁盘的数据库系统通常使用缓冲池技术来提高数据库的整体性能

   缓冲池就是一块内存区域，通过内存的速度来弥补磁盘速度较慢对数据库性能的影响。在数据库中进行读取页的操作，首先将从磁盘读到的也存放在缓冲池中，这个过程称为将也“FIX”在缓冲池中，下次再读取相同的页时，首先判断该页是否在缓冲池中，若在缓冲池中，称该页被缓冲池中被命中，直接读取该页，否则，读取磁盘上的页。

   对于数据库中也的修改操作，则首先修改缓冲池中的页，然后再以一定的频率刷新到磁盘上，这里需要注意的是 **页从缓冲池刷新回磁盘的操作并不是在每次页发生更新时触发，而是通过一种称为Checkpoint的机制刷新会磁盘**

   综上所述，缓冲池的大小直接影响着数据库的整体性能。

   具体来看，缓冲池中缓存的数据页类型有：索引页，数据页、undo页、插入缓冲、自适应哈希索引、InnoDB存储的锁信息、数据字典信息。不能简单的认为，缓冲池只是缓存索引页和数据页和数据页。

   ![](InnoDB存储引擎附录/InnoDB 内存数据对象.png)
   从InnoDB 1.0.x开始，允许有多个缓冲池实例，每个页根据哈希值平均分配到不同缓冲池实例中，这样做的好处是减少数据库内部的资源竞争，增加数据库的并发处理能力。
2. LRU List、Free List 和Flush List

   通常来说 数据库中的缓冲池是通过LRU（最近最少使用）算法来进行管理的。即最频繁使用的页在LRU列表的前端，最少使用的页在LRU列表的尾端，当缓冲池不能存放新读取的页时，将首先释放LRU列表中尾端的页。

   lru链表：用来存储内存中的缓存数据。
   free链表：用来存放所有的空闲页，每次需要数据页存储数据时，就首先检测free中有没有空闲的页来分配。
   flush链表：在内存中被修改但还没有刷新到磁盘的数据页列表，就是所谓的脏页列表，内存中的数据跟对应的磁盘上的数据不一致，属于该列表的页面同样存在于lru列表中，但反之未必。

3. 重做日志缓存

   InnoDB的内存区域除了有缓冲池外，还有重做日志缓冲，InnoDB首先将重做日志信息先放入这个缓冲区，然后按一定频率刷新到重做日志文件。重做日志缓存一般不需要设置的很大，一般情况下每一秒都会将重做日志缓存刷新到日志文件，因此用户只需要保证每秒产生的事务量在这个缓冲大小之内即可。

<h3>2.4 Checkpoint技术 </h3>   
页的操作都是在缓冲池中完成的，数据库会定期将新版本的页从缓冲池刷新到磁盘。
   
但是如果每次变化后都立刻刷新进磁盘，数据库的性能就会变差，但是如果时间太长，数据库在此期间内宕机，就会导致部分数据丢失。

为了避免数据丢失的问题，当前事务都采取了 write Ahead log策略，即当事务提交时，先写重做日志，再修改页，当发生宕机导致数据丢失时，通过重做日志来完成数据的恢复。

Checkpoint技术是为了解决以下的问题：
   1. 缩短数据库的回复时间
   2. 缓冲池不够用时，将脏页刷新到磁盘
   3. 重做日志不可用时，刷新脏页

当数据库发生宕机时，数据库不需要重做所有的日志，因为 Checkpoint之前的页都已经刷回磁盘，故数据库只需要对Checkpoint 之后的重做日志进行恢复，打打缩短了恢复的时间。

此外，当缓冲池不够用时，根据LRU算法会溢出最近最少使用的页，这个页就是脏页，那么需要强制执行 Checkpoint ，将脏页刷回磁盘。

重做日志出现不可用的情况是因为当前事务数据库系统对重做日志的设计都是循环使用的，并不是让其无限增大的，这从成本管理上都是比较困难的，重做日志可以被重用的部分是指这些重做日志已经不再需要，即当数据库发生宕机时，数据库恢复操作不需要这部分的重做日志，因此这部分就可以被覆盖重用。此时重做日志还需要使用，那么必须强制产生 Checkpoint ，将缓冲池中的也至少刷新到当前重做日志的位置。

对于InnoDB而言，通过LSN（Long sequence Number）来标记版本的。 LSN是8字节的数字，单位是字节。

在InnoDB中，每次刷新多少页到磁盘、每次从哪里取脏页以及什么时间出发Checkpoint，在存储引擎内部一共有两种，分别为：
1. Sharp Checkpoint
2. Fuzzy Checkpoint

Sharp Checkpoint发生在数据库关闭时所有的脏页都刷新回磁盘，这是默认的工作方式。

Fuzzy Checkpoint 只刷新一部分脏页，而不是刷新所有的脏页回磁盘。在以下几种情况可能出现Fuzzy Checkpoint
1. Master Thread Checkpoint

差不多以每秒或每十秒的速度从缓冲池的脏页列表中刷新一定比例的页回磁盘。这个过程是异步的，此时的InnoDB可以进行其他操作，用户查询线程不会阻塞。
2. FLUSH_LRU_LIST Checkpoint

InnoDB需要保证LRU列表中需要有差不多100个空闲页可供使用，如果空闲页不足100时，InnoDB会将LRU尾部的页移除，如果这些页中有脏页的话，就会进行 Checkpoint
3. Async/Sync Flush Checkpoint

重做日志文件不可用时，需要强制将一些也刷新回磁盘，此时脏页是从脏页列表中选取的。在MySQL 5.6之前，会阻塞用户线程，5.6之后不会阻塞用户线程
4. Dirty Page too much Checkpoint
最后一种是脏页太多，导致InnoDB 强制进行 Checkpoint，是为了保证缓冲池中有足够可用的页。


<h2>2.5 Master Thread </h2>
InnoDB的主要工作都是在一个单独的后台线程 Master Thread中完成的。

<h3>2.5.1 InnoDB 1.0.x之前的 Master Thread </h3>
Master Thread 具有最高的线程优先级别。其内部由多个loop组成：主循环、后台循环、刷新循环、暂停循环。Master Thread 会根据数据库运行的状态在这几种状态中循环。

主循环通过 Thread.sleep()实现，每一秒操作包括：
1. 日志缓存刷新到磁盘，即使这个事务还没有提交（总是）
2. 合并插入缓存（可能）
3. 之多刷新100个InnoDB的缓冲池中的脏页到磁盘（可能）
4. 如果当前没有用户活动，则切换到background loop（可能）

每10秒的操作包括：
1. 刷新100个脏页到磁盘（可能的情况下）
2. 合并最多5个插入缓冲（总是）
3. 将日志缓冲刷新到磁盘（总是）
4. 删除无用的Undo页（总是）
5. 刷新100个或者10个脏页到磁盘（总是）

即使某个事务还没有提交，InnoDB任然每秒会将重做日志缓冲中的内容刷新到重做日志文件，这种方式可以使再大的事务提交的时间也是很短的。

合并插入缓存并不是每秒都会发生的，InnoDB会判断当前一秒内的IO是否小于5次，如果小于5次，InnoDB认为当前的IO压力很小，可以执行合并插入缓冲的操作。

若当前没有用户活动，或者数据库空闲时，就会切换到后台循环。后台循环会执行以下操作：
1. 删除无用的undo页（总是）
2. 合并20个插入缓冲（总是）
3. 调回到主循环（总是）
4. 不断刷新100个页直到符合条件（可能，跳转到 刷新循环）

<h2>2.6 InnoDB 关键特性 </h2>
InnoDB 存储引擎的关键特性包括
1. 插入缓冲（Insert Buffer）
2. 两次写（Double Write）
3. 自适应哈希索引（Adaptive Hash Index）
4. 异步IO（Async IO）
5. 刷新邻接页（Flush Neighbor Page）

<h2>2.6.1 插入缓冲 </h2>
<h3>1.Insert Buffer </h3>
在InnoDB中，主键是行唯一的标识符，通常应用程序中记录的插入顺序是按照主键递增的顺序进行插入的，因此，插入聚集索引一般是顺序的，不需要磁盘的随机读取
```sql
 CREATE TABLE t(
     a INT AUTO_INCREMENT,
     b varchar(30),
     PRIMARY KEY (a),
     key(b)
 )
```
其中 a列是自增长的，若对a插入NULL 则由于其具有 AUTO_INCREMENT 属性，其值会自动增长

同时页中的行记录按a的值进行顺序存放，在一半情况下，不需要随机读取另一个页中的记录。因此，对于这类情况下的插入操作，速度是非常快的。

**_注意：并不是所有的主键插入都是顺序的，若主键是UUID这样的类，那么插入和辅助索引一样，同样是随机的。即使主键是自增类型，但是插入的是指定的值，而不是NULL值，那么同样可能导致插入非连续的情况。_**

更多情况下，一张表上有多个非聚集的辅助索引，比如，用户需要按照b这个字段进行查找，并且b这个字段不是唯一的。

在这种情况下，产生了一个非聚集的且不是唯一的索引，在进行插入操作时，数据页的存放还是按主键a进行顺序存放的，但是对于非聚集索引叶子结点的插入不再是顺序的了，这时候就需要离散地访问非聚集索引页，由于随机读取的存在而导致了插入操作性能下降。当然这并不是这个b字段上索引的错误，而是因为B+树的特性决定了非聚集索引插入的离散性。

InnoDB存储引擎开创性的设计了Insert Buffer，对于非聚集索引的插入或更新操作，不是每一次直接插入到索引页中，而是先判断插入的非聚集索引页是否在缓冲池中，若在，则直接插入，则先放入到一个Insert Buffer 对象中，然后再以一定的频率和情况，将Insert Buffer 和辅助索引页子节点的merge操作，这时通常会将多个插入合并到一个操作中，大大提高了对于非聚集索引插入的性能。

Insert Buffer 的使用需要满足以下两个条件：
1. 索引是辅助索引
2. 索引不是唯一的。

当满足以上两个条件时，Innodb 存储引擎会使用Insert Buffer ，这样就能提高插入操作的性能了。

<h3>2.Change Buffer </h3>
Innodb从1.0.x版本中开始引入了Change Buffer，可将其看做 Insert Buffer 的升级。
从这个版本开始，Innodb 存储引擎可以对DML（Insert、delete、update）操作都进行缓冲，它们分别是 Insert Buffer、 Delete Buffer、 Purge Buffer

当然和之前一样，Change Buffer适用的对象依然是非唯一的辅助索引。
对一条记录的update 操作可能分为两个过程：
1. 将记录标记为删除
2. 将记录真正删除

因此Delete Buffer 对应Update 操作的第一个过程，即将记录标记为删除，Purge Buffer对应update操作的第二个过程，即将记录真正的删除。同时，Innodb存储引擎提供了参数innodb_change_buffering，用来开启各种Buffer的选项。该参数可选的值为：Inserts、deletes、purges、changes、all、none。
changes表示启用inserts和deletes，all表示启用所有，none表示都不启用，该参数默认值为all。

innodb_change_buffer_max_size值默认为25，表示最多1/4的的缓冲池空间，而需要注意的是，该值最大为50；
<h3>3.Insert Buffer的内部实现 </h3>
Insert Buffer的内部是一颗B+树，在MySQL 4.1之前的版本中，每张表有一个Insert Buffer的B+树，在4.1之后的版本中，全局只存在一颗B+树，负责对所有表的辅助索引进行Insert Buffer。

这颗B+树存放在共享表空间中(默认存放在ibdata1中)，因此，试图通过独立表空间ibd文件恢复表中数据时，往往会导致Check Table失败。这是因为表的辅助索引中的数据还在Insert Buffer中，也就是共享表空间中，所以通过ibd文件进行恢复后，还需要进行Repair Table操作来重建表上的所有辅助索引。


Insert Buffer 是一颗B+树，因此它也是由叶节点和非叶节点组成。非叶节点存放的是查询的 search key

| space | marker | offset |
|-------|--------|--------|

search key 一共占用9个字节，其中 space表示待插入记录所在表的表空间id，在Innodb中，每个表都有一个唯一的space id，可以通过space id 查询是哪张表，space占用4个字节。
marker占用1个字节，它是用来兼容老版本的Insert Buffer。offset表示页所在的偏移量，占用4个字节。

当一个辅助索引要插入到页时，如果这个页不在缓冲池中，那么Innodb首先根据上面的规则构建一个Search key 接下来查询 Insert Buffer 这颗B+树，然后再讲这条记录插入到Insert Buffer B+树的叶子节点中 。

对于插入到Insert Buffer B+树叶子节点的记录，并不是直接将待插入的记录插入，而是需要根据如下的规则进行构造

| space | marker | offset | metadata | | | |
|-------|--------|--------|----------|-|-|-|

增加第4个字段 metadata 字段，这个字段共占用4个字节，2个字节记录排序每个记录进入Insert Buffer 的顺序


<h2>2.7 启动、关闭与恢复 </h2>
指的是MySQL实例的启动过程之中对Innodb存储引擎的处理过程。

<h3>关闭参数 Innodb_fast_shutdown</h3>
在关闭时，参数Innodb_fast_shutdown 影响着表的存储引擎为Innodb的行为，该取值可以为0、1、2，默认是为1

0 表示在数据库关闭时，Innodb要完成所有的full purge 和merge insert Buffer，并且将所有的脏页刷新回磁盘，这需要一些时间，有时甚至需要几个小时来完成。

1 表示不需要完成上述的full purge和merge insert Buffer 操作，但是在缓冲池中的一些数据脏页还是会刷新回磁盘

2 表示不完成 full purge和merge insert Buffer 操作，也不讲缓冲池中的数据脏页写回磁盘，而是将日志都写入日志文件，这样不会有任何事务的丢失，但是下次MySQL启动的时候，会进行回复操作

当使用kill命令关闭数据库，或直接重启服务器，或者将参数设置为2 下次MySQL启动的时候，都会对Innodb存储引擎的表进行恢复操作

<h3>恢复参数 Innodb_force_recovery</h3>

参数 Innodb_force_recovery影响的是整个Innodb存储引擎回复的状况，该参数默认为0 代表当发生需要恢复时，进行所有的恢复操作，当不能进行有效恢复时，如数据页发生了corruption，MySQL可能会党纪，并把错误写入到错误日志去

但是在某些情况下，可能并不需要进行完整的恢复操作，因为用户自己知道怎么进行恢复，比如在对一个表进行alter 是出现意外，数据库重启时会对整个表进行回滚，对于一个大表来说可能要几个小时才能恢复，这时用户可以自行恢复，比如整个表进行删除，然后从备份表中重新导入数据。

参数值还有其他6个非0值

1 忽略检查到的corrupt页

2 阻止Master Thread线程的运行，如Master Thread 需要进行full purge操作，而这个操作会导致crash

3 不进行事务的回滚操作

4 不进行插入缓冲的合并操作

5 不查看撤销日志，Innodb会将未提交的事务视为已提交

6 不进行回滚操作

<h1>3 文件</h1>

文件一共有6种文件

参数文件： 配置文件

日志文件：错误日志、慢查询日志（可通过设置long_query_time参数设置 还可设置 log_queries_not_using_indexes 设置 将未使用索引的sql也记录到慢查询日志中）、二进制日志、查询日志等

socket文件：当用unix域套接字方式进行连接时需要的文件

pid文件：实例的进程id文件

表结构文件：放表结构定义文件

存储引擎文件：各个不同的存储引擎会有自己的文件，存储数据、索引的文件

日志中的二进制日志作用非常关键，可以用来进行point in time的恢复及复制环境的搭建，因此，建议在任何时候都启用二进制日志的记录，从MySQL5.1开始二进制日志支持statement、row、mix 三种格式，这样可以更好的保证从数据库与主数据库之间的数据一致性

存储引擎文件包括表空间文件和重做日志文件，表空间文件是用来管理Innodb存储引擎的事务日志，也因为重做日志的存在，才使得Innodb存储引擎可以提供可靠的事务

<h1>4 表</h1>
表就是关于特定实体的数据集合

<h2>4.1 索引组织表</h2>

在Innodb存储引擎中，表都是根据主键顺序组织存放的，这种存储方式的表成为索引组织表，在Innodb存储引擎表中，每张表都有个主键key，如果在创建表的时候没有显示的定义主键，则Innodb会按照如下方式选择或创建主键
1. 首先判断表中是否有非空的唯一索引，如果有，则该列即为主键
2. 如果不符合上述条件，Innodb会自动创建一个6字节大小的指针

当表中有多个非空唯一索引时，Innodb会选择建表时的第一个定义的非空唯一索引为主键，这里需要非常注意的是，主键的选择根据的是定义索引的顺序，而不是建表时列的顺序。

<h2>4.2 Innodb逻辑存储结构</h2>

从Innodb的逻辑存储结构看，所有数据都被逻辑的存放在一个空间中，称为表空间。

表空间(tabllespace)又由段(segment)、区(extent)、页(page)组成，页在一些文档中有时也称为块(block)，如下图所示

![Innodb逻辑存储结构.png](InnoDB存储引擎附录/Innodb逻辑存储结构.png)


<h3>4.2.1 表空间</h3>

表空间可以看做是Innodb逻辑结构的最高层，所有的数据都存放在表空间中。

在默认情况下Innodb存储引擎有一个共享表空间ibdata1，即所有数据都存放在这个表空间内。如果用户启用了参数 innodb_file_per_table，则每张表内的数据可以单独放到一个表空间内。

如果启用了innodb_file_per_table 参数，需要注意的是每张表的表空间内存放的只是数据、索引和插入缓冲bitmap页，其他类的数据，如回滚信息，插入缓冲索引页、系统事务信息、二次写缓冲等还是存放在原来的共享表空间内。这同时也说明了另一个问题，即使在启用了参数innodb_file_per_table后，共享表空间还是会不断地增加其大小。


<h3>4.2.2 段</h3>

表空间是由各个段组成的，常见的段有数据段、索引段、回滚段等，Innodb是索引组织的，因此数据即索引，索引即数据。那么数据段即为b+树的叶子节点，索引段即为b+树的非索引节点。

在Innodb中，对段的管理都是由引擎自身所完成，这和oracle的自动段空间管理类似。

<h3>4.2.3 区</h3>

区是由连续页组成的空间，在任何情况下每个区的大小都为1MB，为了保证区中页的连续性，Innodb会一次性从磁盘申请4-5个区，在默认情况下，Innodb存储引擎页的大小为16kb，即一个区中一共有64个连续的页、

Innodb 1.0.x版本开始引入压缩页，即每个页的大小可以通过参数key block size 设置为2k、4k、8k，因此每个区对应页的数量应该为512、256、128个。

Innodb 1.2.x版本新增了参数innodb_page_size，通过改参数可以将默认页的大小设置为4k、8k，但是页中的数据库不是压缩，这时区中页的数量也同样为256、128.总之，不管也得大小怎么变化，区的大小总是1M。

在每个段开始时，先用32个页大小的碎片页来存放数据，在使用完之后才是64个连续页的申请，这样做的目的是，对于一些小表，或者是undo这类的段，可以在开始时申请较少的空间，节省磁盘容量的开销。

<h3>4.2.4 页</h3>

同大多数数据库一样，Innodb有页的概念，也是Innodb磁盘管理的最小单位，在Innodb中，默认每个页的大小为16kb，而从1.2.x版本开始，可以通过参数innodb_page_size 将页的大小设置为4k，8k，16k，若设置完成，则所有表中页的大小都为 innodb_page_size，不可以再次进行修改。

在Innodb存储引擎中，常见的页的类型有：

1. 数据页，
2. undo页
3. 系统页
4. 事务数据页
5. 插入缓冲位图页
6. 插入缓冲空闲列表页
7. 未压缩的二进制大对象页
8. 压缩的二进制大对象页

<h3>4.2.5 行</h3>

Innodb存储引擎是面向列的，也就是说数据是按行进行存放的。 

每个页存放的行记录也是有硬性定义的，最多存放16kb/2-200行的记录，即7992行记录。

<h2>4.3 Innodb 行记录格式</h2>

Innodb 存储引擎和大多数数据库一样，记录是以行的形式存储的，这意味着也中保存着表中一行行的数据，在Innodb 1.0.x 版本之前，Innodb提供了 compact 和redundant 两种格式来存放行记录数据。

在MySQL 5.1版本中，默认设置为compact行格式，数据库实例的作用之一就是读取页中存放的行记录。

<h3>4.3.1 compact行记录格式</h3>

compact行记录是在MySQL 5.0中引入的，其设计目标是高效的存储数据，简单的来说，一个页中存放的行数据越多，其性能就越高。
![compact行记录的格式.png](InnoDB存储引擎附录/compact行记录的格式.png)

从图中可以看到，compact行记录格式的首部是一个非null边长字段长度列表，并且其是按照列的顺序逆序放置的，其长度为：
若列的长度小于255字节，用1字节表示，若大于255字节，用2字节表示。

变长字段的长度最大不可以超过2字节，这是因为在MySQL中varchar类型的最大长度限制为65535

变长字段之后的第二部分是null标志位，该位指示了该行记录是否有null值，有则用1表示，该部分所占的字节应该为1字节。

接下来的部分是记录头信息，固定占用5字节，如下图所示。
![compact记录头信息.png](InnoDB存储引擎附录/compact记录头信息.png)

最后的部分就是实际存储每个列的数据，需要注意的是，null不占该部分的任何空间，即null除了占有null标志位，实际存储不占有任何空间。

还有一个需要注意的是，每行数据除了用户定义的列外，还有两个隐藏列，事务id列和回滚指针列，分别为6字节和7字节大小，若表中没有定义主键，每行还会增加一个6字节的rowid列

<h3>4.3.2 redundant行记录格式</h3>

redundant行记录格式 是MySQL5.0版本之前Innodb行记录的存储方式，MySQL5.0支持redundant是为了兼容之前版本的页格式，redundant行记录采取下图所示的方式存储
![redundant行记录格式.png](InnoDB存储引擎附录/redundant行记录格式.png)

从图中可以看到，不同于compact行记录格式，redundant行记录格式的首部是一个字段长度偏移列表，同样是按照列的顺序逆序放置的，若列的长度小于255字节，用1字节表示，若列的长度大于255字节，用2字节表示。

第二个部分为记录头信息，不同于compact行记录可以，redundant行记录格式的记录头占用6个字节,如图所示

![redundant记录头信息.png](InnoDB存储引擎附录/redundant记录头信息.png)

与compact不同的是，redundant对于varchar类型的null值，不占用任何存储空间，而char格式的null值需要占用存储空间

<h3>4.3.3 行溢出数据</h3>

Innodb存储引擎可以将一条记录中的某些数据存储在真正的数据页之外，一般认为blob，lob这类的大对象列类型的存储会把数据存放在数据页之外，其实即使是blob可以不将数据放在溢出页面，varchar依然有可能被存放为溢出数据。

当发生溢出时，数据会存放在uncompress blob页中，从二进制文件可以看出，数据页只存了varchar（65532）的前768字节的前缀数据，之后是偏移量，指向行溢出页。因此，对于行溢出数据，采用的存放方式如图：
![行溢出存储数据方式.png](InnoDB存储引擎附录/行溢出存储数据方式.png)
一般来说，一个页上会至少存放2条数据，为了每个页上能放至少两条数据，阈值的大小为8098

<h2>4.4 Innodb 数据页结构</h2>

暂时略过

<h2>4.4 Named file formats机制</h2>
