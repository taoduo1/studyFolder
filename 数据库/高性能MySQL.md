<h1>MYSQL架构</h1>
MySQL架构图

![](高性能MySQL附录/MySQL架构图.png)

客户端就是使用MySQL的客户端

大部分MySQL的核心服务都在第二层，包括查询解析、分析、优化、缓存及所有的内置函数，所有的存储引擎功能都在此实现，包括存储引擎、触发器、视图等。

第三层包含了存储引擎，存储引擎负责数据的存储和提取，包含几十个底层函数，用于执行“开始一个事务”或“根据主键查询一条记录”等。存储引擎不会去解析SQL，不同存储引擎之间也不会相互通信，只是简单的响应上层服务器的请求。
<h2>连接管理</h2>
每个客户端都会在服务器进程中有一个线程，这个连接的查询只会在这个单独的线程中执行，服务器会缓存线程，因此不需要为每一个链接创建或者销毁线程。
<h2>优化执行</h2>
MySQL会解析查询，并创建内部数据结构，然后对其进行各种优化，包括重写查询、决定表的读取顺序以及选择合适的索引等。
<h2>并发控制</h2>
1. 读写锁  
    读锁是共享的，多个客户端可以同时读取互不影响，写锁是排他的，写锁会阻塞其他的写锁和读锁
2. 锁粒度
    锁粒度就是在锁的开销和数据的安全性之间追求平衡，MySQL提供了两种锁粒度以供选择：表锁和行级锁。
   1. 表锁：是MySQL最基本的锁策略，并且是开销最小的策略。表锁会锁定整张表，在特定场景下，表锁也有良好的性能。
   2. 行级锁：行级锁可以最大程度的支持并发处理（但同时锁开销也是最大），行级锁只在存储引擎层实现。

<h2>事务</h2>
事务具有：原子性、一致性、隔离性和持久性
1. 原子性：一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部成功，要么全部失败，不能只执行一部分。
2. 一致性：数据库总是从一个一致性的状态转到另一个一致性的状态。
3. 隔离性：一个事务提交之前，对其他事务来说是不可见的
4. 持久性:一旦事务提交、则其所作的修改就会永久保存在数据库中。

<h3>隔离级别</h3>
SQL标准中定义了4种隔离级别，每一种都规定了一个事务中所作的修改，在哪些事务内和事务间是可见的。
SQL中共定义了四种隔离级别。
1. READ UNCOMMITTED(未提交读)
事务中的修改，即使没有提交，对其他事务也都是可见的。这个级别会导致脏读出现（一条数据还没落地就被读到了，然后此数据因异常未成功落库，导致读到了不该读的数据）。实际应用较少
2. READ COMMITTED(提交读)
大部分的数据库默认的事务隔离级别都是提交读(但是MySQL不是)，提交读是一个事务从开始直到提交之前，所作的任何修改对其他事务都是不可见的，也叫不可重复读。
也就是事务A在读取一条数据后，事务B提交了这条数据的修改，事务A又去读取这条数据，第一次和第二次读取到的就是不一样的数据。
3. REPEATABLE READ(可重复读)
可重复读和提交读的区别就是，提交读在第二次读到的是最新的数据，但是可重复读会读到原来数据的拷贝。这个也叫做幻读
4. SERIALIZABLE(可串行化)
通过强制事务串行执行，是数据安全级别最高的隔离级别，会在读取的每一行数据上都加锁，现实一般很少应用到。

<h3>死锁</h3>
```sql
start transaction; 
update table set status = '1' where id = 1;
update table set status = '2' where id = 2;
commit ;

start transaction;
update table set status = '2' where id = 2;
update table set status = '3' where id = 1;
commit ;
```
两个更新语句，第一个事务会给第一条数据加锁，第二个事务是给第二条加锁，
第一个事务执行完第一条更新语句会去获取第二条数据的锁，但是没有释放第一条数据的锁
第二个事务执行完第一条更新语句会去获取第二条数据的锁，但是没有释放第一条数据的锁
两个事务出现互相等待释放锁的死循环行为，这个就是死锁。
死锁发生之后，只有部分或者完全回滚一个事务，才会解决这个死锁。

<h3>MySQL中的事务</h3>
MySQL提供了两种事务型的存储引擎：InnoDB和NDB Cluster。另外还有一些第三方存储引擎也支持事务，例如：XtraDB和PBXT。  

MySQL 默认使用 **自动提交（AUTOCOMMIT）** 模式。此模式下，如果不是显示的开始一个事务，则每个查询都会被当做一次事务执行提交操作，可以通过设置修改模式。  
当禁用自动提交的时候，所有的查询都是在一个事务里，直到显示的执行commit提交或者ROLLBACK 回滚，该事务结束时，同时会开启一个新事务。  
对于没有事务的存储引擎的表，没有commit和rollback的概念，可以理解为一直开启自动提交的状态。  
还有一些命令，在执行之前会强制执行commit提交当前活动的事务，例如ALTER TABLE。  
MySQL可以通过SET TRANSCATION ISOLATION LEVEL命令来设置隔离级别，新的隔离级别会在下个事务开始的时候生效。  

在事务中混合使用存储引擎
MySQL服务层是不管理事务的，所有事务是由下层的存储引擎实现的，如果在同一个事务中，使用多种存储引擎是不可靠的。
如果在事务中混合使用了事务型和非事务型的表（例如InnoDB和MyISAM），如果这个事务需要回滚，非事务型的表会无法撤销操作，同时回滚会发出警告。

隐式和显示锁定
InnoDB才用的是两段式锁定协议，在事务的执行过程中，随时都可以执行锁定，锁只有在执行COMMIT和ROLLBACK 的时候才会释放，并且锁是在同一时刻释放，这个是隐式锁定，MySQL会根据隔离级别需要的时候自动加锁。

MySQL也支持LOCK TABLES和 UNLOCK TABLES 语句，这个是在服务器层实现的，和存储引擎无关，这个是有自己的使用场景，不能代替事务处理，如果需要用到事务，应该要选择事务型的存储引擎。

LOCK TABLES 语句和事务同时使用的时候，情况会变的很复杂，在某些MySQL版本中甚至会产生无法预料的情况，为了避免产生这种情况，建议任何时候都不要显示的执行 LOCK TABLES ，无论是什么存储引擎。

<h3>多版本并发控制</h3>
MySQL的大多数事务型存储引擎实现的都不是简单的行级锁，而是基于提升并发性能的多版本并发控制（MVCC）。
MVCC 可以视为是行级锁的一个变种，但它是在很多情况下避免了加锁操作，因此开销更低，虽然实现机制不一致，但是大多数走的都是非阻塞读，写操作也只锁定必要的行，有点类似于读写锁、
MVCC的实现是通过保存数据在某个节点的快照来实现的。一个事务不管执行多长时间，对同一条数据读取的都一致的。
不同存储引擎的MVCC 的实现方式是不同的，典型的有乐观锁和悲观锁两种,例如InnoDB。
InnoDB的MVCC 是通过每行记录后面保存两个隐藏的列来实现的，这两个列一个保存了行的创建时间，一个保存行的过期时间（或删除时间），存储的内容为系统版本号，每开始一个事务，版本号都会递增，事务开始时的系统版本号会作为本事务的版本号，用来和查询到的每行记录号进行比较。
在REPATABLE READ隔离级别下，
1. SELECT
    InnoDB会根据以下两个条件检查每行记录：
   1. InnoDB 只查找版本早于当前事务版本的数据，这样可以确保事务读取的行，要么是事务开始之前已经存在了的，要么是事务自己插入或修改的。
   2. 行的删除要么未定义，要么大于当前事务版本号，这可以确保事务读取到的行，在事务开始之前未删除。
2. insert
    新插入的行保存当前系统版本号作为行版本号。
3. delete 
    删除的每一行保存当前系统版本号作为删除标识。
4. update
    为插入一行新记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行，作为删除标记
保存这两个版本号，可以使大多数操作不用加锁，使得读数据库操作简单，性能更好，不足之处就是每行记录的修改都需要额外空间，需要更多的检查工作以及一些额外的维护工作。








<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>


<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
