<h1>MYSQL架构</h1>
MySQL架构图

![](高性能MySQL附录/MySQL架构图.png)

客户端就是使用MySQL的客户端

大部分MySQL的核心服务都在第二层，包括查询解析、分析、优化、缓存及所有的内置函数，所有的存储引擎功能都在此实现，包括存储引擎、触发器、视图等。

第三层包含了存储引擎，存储引擎负责数据的存储和提取，包含几十个底层函数，用于执行“开始一个事务”或“根据主键查询一条记录”等。存储引擎不会去解析SQL，不同存储引擎之间也不会相互通信，只是简单的响应上层服务器的请求。
<h2>连接管理</h2>
每个客户端都会在服务器进程中有一个线程，这个连接的查询只会在这个单独的线程中执行，服务器会缓存线程，因此不需要为每一个链接创建或者销毁线程。
<h2>优化执行</h2>
MySQL会解析查询，并创建内部数据结构，然后对其进行各种优化，包括重写查询、决定表的读取顺序以及选择合适的索引等。
<h2>并发控制</h2>
1. 读写锁  
    读锁是共享的，多个客户端可以同时读取互不影响，写锁是排他的，写锁会阻塞其他的写锁和读锁
2. 锁粒度
    锁粒度就是在锁的开销和数据的安全性之间追求平衡，MySQL提供了两种锁粒度以供选择：表锁和行级锁。
   1. 表锁：是MySQL最基本的锁策略，并且是开销最小的策略。表锁会锁定整张表，在特定场景下，表锁也有良好的性能。
   2. 行级锁：行级锁可以最大程度的支持并发处理（但同时锁开销也是最大），行级锁只在存储引擎层实现。

<h2>事务</h2>
事务具有：原子性、一致性、隔离性和持久性
1. 原子性：一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部成功，要么全部失败，不能只执行一部分。
2. 一致性：数据库总是从一个一致性的状态转到另一个一致性的状态。
3. 隔离性：一个事务提交之前，对其他事务来说是不可见的
4. 持久性:一旦事务提交、则其所作的修改就会永久保存在数据库中。

<h3>隔离级别</h3>
SQL标准中定义了4种隔离级别，每一种都规定了一个事务中所作的修改，在哪些事务内和事务间是可见的。
SQL中共定义了四种隔离级别。
1. READ UNCOMMITTED(未提交读)
事务中的修改，即使没有提交，对其他事务也都是可见的。这个级别会导致脏读出现（一条数据还没落地就被读到了，然后此数据因异常未成功落库，导致读到了不该读的数据）。实际应用较少
2. READ COMMITTED(提交读)
大部分的数据库默认的事务隔离级别都是提交读(但是MySQL不是)，提交读是一个事务从开始直到提交之前，所作的任何修改对其他事务都是不可见的，也叫不可重复读。
也就是事务A在读取一条数据后，事务B提交了这条数据的修改，事务A又去读取这条数据，第一次和第二次读取到的就是不一样的数据。
3. REPEATABLE READ(可重复读)
可重复读和提交读的区别就是，提交读在第二次读到的是最新的数据，但是可重复读会读到原来数据的拷贝。这个也叫做幻读
4. SERIALIZABLE(可串行化)
通过强制事务串行执行，是数据安全级别最高的隔离级别，会在读取的每一行数据上都加锁，现实一般很少应用到。

<h3>死锁</h3>
```sql
start transaction; 
update table set status = '1' where id = 1;
update table set status = '2' where id = 2;
commit ;

start transaction;
update table set status = '2' where id = 2;
update table set status = '3' where id = 1;
commit ;
```
两个更新语句，第一个事务会给第一条数据加锁，第二个事务是给第二条加锁，
第一个事务执行完第一条更新语句会去获取第二条数据的锁，但是没有释放第一条数据的锁
第二个事务执行完第一条更新语句会去获取第二条数据的锁，但是没有释放第一条数据的锁
两个事务出现互相等待释放锁的死循环行为，这个就是死锁。
死锁发生之后，只有部分或者完全回滚一个事务，才会解决这个死锁。

<h3>MySQL中的事务</h3>
MySQL提供了两种事务型的存储引擎：InnoDB和NDB Cluster。另外还有一些第三方存储引擎也支持事务，例如：XtraDB和PBXT。  

MySQL 默认使用 **自动提交（AUTOCOMMIT）** 模式。此模式下，如果不是显示的开始一个事务，则每个查询都会被当做一次事务执行提交操作，可以通过设置修改模式。

当禁用自动提交的时候，所有的查询都是在一个事务里，直到显示的执行commit提交或者ROLLBACK 回滚，该事务结束时，同时会开启一个新事务。

对于没有事务的存储引擎的表，没有commit和rollback的概念，可以理解为一直开启自动提交的状态。

还有一些命令，在执行之前会强制执行commit提交当前活动的事务，例如ALTER TABLE。

MySQL可以通过SET TRANSCATION ISOLATION LEVEL命令来设置隔离级别，新的隔离级别会在下个事务开始的时候生效。  

在事务中混合使用存储引擎
MySQL服务层是不管理事务的，所有事务是由下层的存储引擎实现的，如果在同一个事务中，使用多种存储引擎是不可靠的。
如果在事务中混合使用了事务型和非事务型的表（例如InnoDB和MyISAM），如果这个事务需要回滚，非事务型的表会无法撤销操作，同时回滚会发出警告。

隐式和显示锁定
InnoDB才用的是两段式锁定协议，在事务的执行过程中，随时都可以执行锁定，锁只有在执行COMMIT和ROLLBACK 的时候才会释放，并且锁是在同一时刻释放，这个是隐式锁定，MySQL会根据隔离级别需要的时候自动加锁。

MySQL也支持LOCK TABLES和 UNLOCK TABLES 语句，这个是在服务器层实现的，和存储引擎无关，这个是有自己的使用场景，不能代替事务处理，如果需要用到事务，应该要选择事务型的存储引擎。

LOCK TABLES 语句和事务同时使用的时候，情况会变的很复杂，在某些MySQL版本中甚至会产生无法预料的情况，为了避免产生这种情况，建议任何时候都不要显示的执行 LOCK TABLES ，无论是什么存储引擎。

<h3>多版本并发控制</h3>
MySQL的大多数事务型存储引擎实现的都不是简单的行级锁，而是基于提升并发性能的多版本并发控制（MVCC）。

MVCC 可以视为是行级锁的一个变种，但它是在很多情况下避免了加锁操作，因此开销更低，虽然实现机制不一致，但是大多数走的都是非阻塞读，写操作也只锁定必要的行，有点类似于读写锁、 MVCC的实现是通过保存数据在某个节点的快照来实现的。一个事务不管执行多长时间，对同一条数据读取的都一致的 。

不同存储引擎的MVCC 的实现方式是不同的，典型的有乐观锁和悲观锁两种,例如InnoDB。

InnoDB的MVCC 是通过每行记录后面保存两个隐藏的列来实现的，这两个列一个保存了行的创建时间，一个保存行的过期时间（或删除时间），存储的内容为系统版本号，每开始一个事务，版本号都会递增，事务开始时的系统版本号会作为本事务的版本号，用来和查询到的每行记录号进行比较。
在REPATABLE READ隔离级别下，

1. SELECT
    InnoDB会根据以下两个条件检查每行记录：
   1. InnoDB 只查找版本早于当前事务版本的数据，这样可以确保事务读取的行，要么是事务开始之前已经存在了的，要么是事务自己插入或修改的。
   2. 行的删除要么未定义，要么大于当前事务版本号，这可以确保事务读取到的行，在事务开始之前未删除。
2. insert
    新插入的行保存当前系统版本号作为行版本号。
3. delete 
    删除的每一行保存当前系统版本号作为删除标识。
4. update
    为插入一行新记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行，作为删除标记
保存这两个版本号，可以使大多数操作不用加锁，使得读数据库操作简单，性能更好，不足之处就是每行记录的修改都需要额外空间，需要更多的检查工作以及一些额外的维护工作。

<h3>MySQL的存储引擎</h3>
在文件系统中，MySQL将每个数据库（也可以称为schema）保存为数据目录下的一个字目录。创建表时，MySQL会在数据库子目录下创建一个和表同名的.frm文件保存表的定义。

例如创建一个名为MyTable的，MySQL会在MyTable.frm文件中保存该表的定义。因为MySQL使用文件系统的目录和文件来保存数据库和表的定义，大小写敏感性和具体的平台密切相关，在Windows中，大小写是不敏感的，而在类Unix中则是敏感的。

不同的存储引擎保存数据和索引的方式是不同的，但表的定义则是在MySQL服务层统一处理的。

<h4>InnoDB存储引擎</h4>

InnoDB是MySQL的默认事务型引擎，InnoDB的数据存储在表空间中，表空间是由InnoDB管理的一个黑盒子，由一系列的数据文件组成。

InnoDB采用MVCC来支持高并发，并且实现了四个标准的隔离级别，默认级别是 REPEATABLE READ（可重复读），并且通过间隙锁策略防止幻读的出现，间隙锁使得InnoDB不仅仅锁定查询涉及的行，还会对索引中的间隙进行锁定，以防止幻行的插入。

InnoDB是基于聚簇索引建立的，聚簇索引对主键查询有很高的性能，不过它的二级索引中必须包含主键列，所以如果主键列很大的话，其他的索引都会很大，因此，若表上的索引较多的话，主键应当尽可能的小。

InnoDB通过一些机制和工具支持真正的热备份，MySQL的其他存储引擎不支持热备份

<h3>MyISAM存储引擎</h3>

在MySQL5.1及之前的版本MyISAM是默认的存储引擎，提供了大量特性，但是不支持事务和行级锁

MyISAM 会将表存储在两个文件中，数据文件和索引文件，分别以.MYD和.MYI为扩展名。

MyISAM 特性
1. 加锁与并发：MyISAM 对整张表加锁，而不是针对行，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁，但是在表有读取查询的同时，也可以往表中插入新纪录（也被称为并发插入）
2. 修复：对于MyISAM表，MySQL可以手工或者自动执行检查和修复操作，是通过CHECK TABLE mytable 检查表的错误，如果有错误可以通过执行 REPAIR TABLE mytable 进行修复
3. 索引特性：对于MyISAM 表，即使是BLOB和TEXT等长字段，也可以基于其前500个字符创建索引，MyISAM也支持全文索引，这是基于分词创建的索引，可以支持复杂的查询
4. 延迟更新索引键：创建MyISAM表的时候，如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完时，不会立即将修改的索引数据写入磁盘，而是会写入到内存的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入到磁盘，这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃的时候会造成索引损坏，需要执行修复操作。

注：MyISAM 引擎设计简单，数据以紧密的格式存储，所以在某些场景下的性能很好，但是MyISAM 最典型的性能问题还是表锁的问题，如果发现所有的查询都长期处于 “Locked” 状态，那就是表锁的问题。


<h4>如何选择合适的存储引擎</h4>
大部分情况下，InnoDB都是正确的选择，所以InnoDB被作为默认的存储引擎。

除非需要用到某些InnoDB不具备的特性，并且没有其他办法可以替代，否则都应该优先选择InnoDB。

例如：如果要用到全文索引，建议优先考虑InnoDB加上Sphinx的组合，而不是使用支持全文索引的MyISAM。

如果不需要用到InnoDB的特性，同时其他引擎的性能能够更好的满足需求，也可以考虑一下其他的存储引擎，如果不在乎崩溃后数据丢失的问题，却对InnoDB的空间占用过多比较敏感，这种场合下选择MyISAM就比较合适（目前没有遇到过这种场景）

除非万不得已，否则建议不要混用多种存储引擎，否则可能带来一系列复杂的问题，以及一些潜在的bug和边界情况的问题。

如果应用需要使用不同的存储引擎以满足业务需求，要考虑一下几个因素：
1. 事务支持：如果需要事务支持，InnoDB是目前最优的选择。
2. 备份：如果可以定期关闭服务器来执行备份，那么备份的因素可以忽略，如果需要热备份，那么InnoDB就是基本的要求
3. 崩溃恢复：MyISAM崩溃会发生损坏的概率是要比InnoDB高狠毒，而且恢复速度也更慢，因此，即使不需要事务支持，很多人也选择了InnoDB
4. 特性：很多应用依赖InnoDB的聚簇索引的优化，或者MyISAM的地理空间搜索

日志型应用

日志信息落库对于插入速度有很高的要求，数据库不能成为瓶颈，MyISAM或者Archive这类存储引擎对这类应用比较合适，因为开销低，并且插入速度很快

如果同时需要对记录的日志做分析报表，生成报表的SQL很可能会导致插入效率降低

一种方式是：利用MySQL内置的复制方案将数据复制一份到备库，然后在备库上进行执行比较消耗时间的查询。
优点：无需担心影响到日志的插入性能
缺点：数据不是实时同步（但是目前接触到的场景来说，大部分时候客户对此功能并不需要实时同步的数据，即使有，也接受不实时同步的方案）
另一种方式是：分表，通过时间分表
优点：无需担心影响到日志的插入性能
缺点：提高了应用的复杂度

只读或大部分情况下只读的表

如果不介意MyISAM的崩溃恢复问题，这种场景下选用MyISAM是合适的。 MyISAM只会将数据写入到内存中，然后等待操作系统定期将数据写入到磁盘中（很有可能断电后丢失）。

在目前很多已知场景中，InnoDB的速度都比MyISAM快，尤其是使用聚簇索引后，大量的数据可以放入内存中，降低读取成本。

在使用MyISAM时，一开始可能没有任务问题，但是随着应用压力上升，可能会迅速恶化，各种锁争用，崩溃后数据丢失的问题都会随之而来。

<h4>转换表的引擎</h4>

1. SQL语句 alter table tableName engine = InnoDB;

2. 可以使用Navicat等工具将数据导出为文件，然后修改文件中引擎选项，然后再导入进去

3. 创建与查询： 新建中间表存储数据，然后删了表重建

<h1> MySQL 基准测试 </h1>
基准测试是针对系统设计的一种压力测试，通常的目标是为了掌握系统的行为，但是也有其他原因，如重现某个系统状态，或者是做新硬件的可靠性测试。

<h2> 为什么要基准测试 </h2>

1. 验证基于系统的一些假设，确认这些假设是否符合实际情况。
2. 重现基于系统中的某些异常，已解决这些异常
3. 测试系统当前的运行情况，如果不清楚系统当前的性能，就无法确认某些优化的效果如何，也可以利用历史的基准测试结果来分析诊断一些无法预测的问题
4. 模拟比当前系统更高的负载，以找出系统随着压力增加而可能遇到的扩展性能瓶颈
5. 规划未来的业务增长，基准测试可以评估在项目未来的负载下，需要什么样的硬件，需要多大容量的网络，以及其他的相关资源，
6. 测试应用使适应可变环境能力，如：不同配置的服务器之间的性能表现，系统对于不同数据分布的处理能力
7. 测试不同的硬件、软件和操作系统配置
8. 证明新采购的配置是否正确

<h2> 基准测试的策略 </h2>
基准测试有两种主要的策略:

1. 针对整个系统的整体测试(测试难度大)
2. 单独测试MySQL(常用测试)

<h3> 测试的指标 </h3>

1. 吞吐量：指单位时间内的事务处理数量。
2. 响应时间或者延迟：测试任务所需的整体时间
3. 并发性：测试同时工作中的线程数或者连接数，当并发增加时，吞吐量和响应时间是否变长
4. 可扩展性：增加资源后，事务处理能力上升比例

<h2> 测试的方法 </h2>
常见错误

1. 使用真实数据的子集而不是全集进行测试(数据样本过少)
2. 使用错误的数据分布(无法发现热点区域，无法正确针对优化)
3. 使用不真实的分布参数(与第二点差不多)
4. 多用户场景中，只做单用户测试
5. 单服务器上测试分布式应用
6. 与真实用户行为不匹配
7. 反复执行同一个查询
8. 没有检查错误
9. 忽略了系统预热的过程
10. 使用默认的服务器配置
11. 测试时间过短

<h3> 设计和规划基准测试 </h3>



<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>


<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
